@using KolBlazor.Components.Timeline

@inject KolTimelineJsInterop TimelineInterop

@inherits KolComponentBase
@implements IAsyncDisposable

<div class="d-flex @Class" >
    <div @ref="scrollElement" class="overflow-scroll scrollbar-none" >
        <KolTimeline MinWidth="1860" UncollapsedHeight="@(State.Model!.Milestones.Count * 36)" 
            ShowTodayLine="true" Class="scrollbar-none py-0" >
            @if (State.Initialized)
            {
                <CascadingValue Value="milestoneTaskFilter" IsFixed="true">
                    @foreach (var milestone in State.Model!.Milestones.OrderBy(x => x.Deadline))
                    {
                        <KolTimelineItem @key="milestone.Id" End="milestone.Deadline" Start="State.GetMilestoneStart(milestone)">
                            <TimelineMilestone Milestone="milestone" />
                        </KolTimelineItem>
                    }
                </CascadingValue>
            }
        </KolTimeline>
    </div>
</div>

@code {
    private ElementReference scrollElement;
    
    [CascadingParameter] IProjectState State { get; set; } = null!;

    private bool firstFilterItemFlag = true;
    private readonly MilestoneTaskFilter milestoneTaskFilter = new();

    protected override void OnInitialized()
    {
        // Remove filter if empty
        milestoneTaskFilter.FilterChanged += () =>
        {
            if (!milestoneTaskFilter.Any())
            {
                State.TaskFilter.RemoveFilter(milestoneTaskFilter);
                firstFilterItemFlag = true;
            }
            else if (firstFilterItemFlag)
            {
                State.TaskFilter.AddFilter(milestoneTaskFilter);
                firstFilterItemFlag = false;
            }
        };

        State.MilestonesChanged += StateHasChanged;
        State.TasksChanged += StateHasChanged;
        State.StateChanged += StateHasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await TimelineInterop.RegisterScrollHandler(scrollElement);
        }
    }
    
    public ValueTask DisposeAsync()
    {
        return TimelineInterop.DisposeAsync();
    }
}