@using Onlyoffice.Api.Models
@using Cardmngr.Application.Clients.Subtask

@implements IDisposable

<div class="flex flex-col gap-2">
    @foreach (var subtask in Task.Subtasks.OrderBy(x => x.Status))
    {
        <SubtaskCard Subtask="subtask" OnEditModeChanged="editMode => _haveEditingSubtask = editMode" />
    }

    @if (_isAddMode && !_haveEditingSubtask)
    {
        <SubtaskCard Subtask="new Subtask { TaskId = Task.Id }" 
                     Class="border-accent border" />
    }
    else
    {
        <div class="rounded-lg p-2 hover:bg-neutral-fill-hover transition-colors @CanAddSubtaskCss"
             @onclick="() => _isAddMode = true" >
            <div class="flex gap-1 rounded-lg px-2 py-1 w-fit text-xs hover:bg-neutral-hover transition-colors">
                <FluentIcon Value="@(new Icons.Filled.Size12.Add())" />
                Добавить подзадачу
            </div>
        </div>
    }
</div>

@code {
    private bool _haveEditingSubtask;
    private bool _isAddMode;

    [Inject] public ISubtaskClient SubtaskClient { get; set; } = null!;

    private string CanAddSubtaskCss => _haveEditingSubtask ? "" : "cursor-pointer";

    [CascadingParameter] OnlyofficeTask Task { get; set; } = null!;
    [CascadingParameter] IProjectState State { get; set; } = null!;
    [CascadingParameter(Name = "MiddleModal")] ModalOptions ModalOptions { get; set; } = null!;
    [CascadingParameter] IModalService Modal { get; set; } = default!;

    protected override void OnInitialized()
    {
        State.SubtasksChanged += StateHasChanged;
    }

    async Task ShowCreationModal()
    {
        var res = await Modal.Show<SubtaskCreationModal>(new ModalParameters { { "Team", State.Team } }, ModalOptions).Result.ConfigureAwait(false);

        if (res.Confirmed)
        {
            var data = (SubtaskUpdateData)res.Data!;
            var added = await SubtaskClient.CreateAsync(Task.Id, data).ConfigureAwait(false);
            State.AddSubtask(Task.Id, added);
        }
    }

    public void Dispose()
    {
        State.SubtasksChanged -= StateHasChanged;
    }
}
